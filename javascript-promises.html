<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>IainPlimmer.co.uk</title>
    <script src="vendor/react.js"></script>
    <script src="vendor/react-dom.js"></script>
    <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <link rel="stylesheet" href="./resources/style.css">
    <script src="./resources/header.js" type="text/babel"></script>
    <script src="./resources/footer.js" type="text/babel"></script>
  </head>
  <body>    
    <div id="header"></div>
    <main>
        <h1>Javascript Promises - Part 2</h1>
        <h5>Posted on 19 December 2016 by Iain Plimmer</h5>
        
        <p>Now that Javascript promises are here natively, without external libraries in 74.46% of browsers (<a href="http://caniuse.com/#search=promise" target="_blank" >July 2016</a>) it's about the right time to start using them over callbacks, but what's are they all about?.</p>
        
        <h3>What are they?</h3>
        
        <p>If you are familiar with callbacks and the pyramid of hell, you're probably looking for an easier way of threading applications in Javascript by now. The problem that this solves is that Javascript is single threaded, and you'll have to wait for an action to complete, for example, calling data from another API, or loading an image that could take some indeterminate amount of time. Promises allow you to effectively wait until they are complete using their built in 'resolve' and 'reject' functions.</p>
        
        <p>When you call a promise, it's comparible to going to a restaurant and making an order, you don't get it straight away, but you know that having your receipt will mean it's handed to you later. A promise is the same. It's a promise that later, you'll get your item.</p>

        <h3>A working example...</h3>

        <p>First things first, we create a new function that returns the promise. To make things simple it will just compare two values and return a promise.</p>
        <p><b>Note: </b> <i>A promise can be 'resolved' or 'rejected'. In this example function there are two input values, and these are the same let's 'resolve' the promise; if not, let's 'reject' it.</i></p>
        <pre>
function CompareNumbers (a, b) {
    return new Promise(function executePromise (resolve, reject) {  
        if (a && b && a === b) {                
            resolve('The values are the same!');
        } else {
            reject('Nope, the values are different');
        }
    });
};</pre>

        <p>Let's call the function that returns the promise now, it's important to note here that we're actually just chaining from the promise and using the 'reject' and 'resolve' functions.</p>

        <pre>
CompareNumbers(1,'1').then(function onSuccess (response) {
    window.alert(response)
})
.catch(function onError(reason){
    window.alert(reason);
});</pre>

        <p>A promise will only ever be in one of the following states, it's important to note that once a promise has completed, you will only ever return it's original response, you will need to create an entirely new promise.</p>
        <ul>
            <li>Pending: initial state, not fulfilled or rejected.</li>
            <li>Fulfilled: meaning that the operation completed successfully.</li>
            <li>Rejected: meaning that the operation failed.</li>
        </ul>

        <h3>Finally...</h3>
        <p>It's best to avoid what JQuery calls a 'promise', they are poorly implemented and confusing. There are some really decent cases on when to use promises, including making HTTP calls to receive data, awaiting user responses (like the example above perhaps) - think about it? when an alert box pops up, you're just waiting on a promise of a response aren't you ;) </p>
        <p>The most important thing though is being out of the 'callback' code structure that we've all been trying to avoid.</p>

    </main>

    <div id="footer"></div>
  </body>
</html>