<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>IainPlimmer.co.uk</title>
    <script src="vendor/react.js"></script>
    <script src="vendor/react-dom.js"></script>
    <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <link rel="stylesheet" href="./resources/style.css">
    <script src="./resources/header.js" type="text/babel"></script>
    <script src="./resources/footer.js" type="text/babel"></script>
  </head>
  <body>    
    <div id="header"></div>
    <main>
     
        <h1><a href="transitioning-to-full-stack.html">Transitioning to Full Stack from ASP.NET</a></h1>
        <h5>Posted on 9 October 2016 by Iain Plimmer</h5>

        <p>This week i've been in the discussion on this very topic on Reddit, a developer raised a question for advice on transitioning to the 'Full Stack&trade;' and was seemingly hitting the same hurdles that I was embroiled with a couple of years ago. I found the whole learning curve far too difficult, fraught with ceremony, necessary build tools, and what has become known popularly as Javascript fatigue.<p> 
        
        <p>When I moved into JQuery 8 years ago using ASP.NET, things were simpler, it was a drop in on the front end. It made the browser idiosyncrasies irrelevant and really made my lives easier with front end scripting; until my applications got larger. And that's all it was: basic scripting to add flourishes and small features. Today, we build entire applications on the front end in ways we never did before. And that's where the curve starts.</p>

        <p>A later reply questioned productivity. In development and bug cycles, it's all about getting things done. Productivity is paramount. ASP.NET & MVC are incredibly productive. However, all being said, there are huge benefits and fringe benefits to creating front ends in Javascript:</p>

        <ul>
            <li><b>Live changes</b>. With a JavaScript application you can make changes live, no recompilation. With live file watchers that link to the browser you're never pressing F5 on every change. Imagine this on a longer timeframe.... It's a huge benefit. There's nothing worse than F5, wait, change, F5 wait, change.</li>
            <li><b>JSON</b>. If you're using MVC, try a data mapping tool like dapper with dynamic types. You can use this to just generate the JSON you need on the front end. Imagine a typical application stack, a database call will likely go - database table, stored procedure, data layer, business layer, thin MVC controller, razor view, JavaScript. Whoa! That's a lot of boilerplate. Using a tool like Dapper with Dynamic types you could just go - database table, dapper sql command, API controller, angular service, angular component. It's no more work, in fact once you've done it a few times it's a fringe benefit. It's just what you need to do.</li>
            <li><b>Live upload</b>. No downtime. Imagine just pushing JavaScript to a CDN or a server directory rather than a full recompilation of a project, organising customer downtime then taking he site down to publish. As long as there are no MVC changes with the feature you can just do it immediately.</li>
            <li><b>Less server load</b>. HTML and JS are cached, you can alter that cache and use manifests to organise when your client needs the HTML again. Push that to the client! Less calls to your server and less load - meaning theoretically a faster user growth rate without scaling. Caching strategy is hard though.</li>
            <li><b>True concern separation</b>. The API can be on a different server - or scaled out to many servers easily. Need more power? Make a copy of the API and point customers there too. Your front end is truly just a front end.</li>
            <li><b>The new project ceremony</b>. Make a seed application that contains the raw elements of what you need in your tool chain. This in turn will remove the ceremony every time you come to scaffold a new appliation. But make the seed yourself, don't reply on someone else's Github. Understand the working parts.</li>
        </ul>



        <h2>My thoughts...</h2>

        <p>It seems highly likely that to develop truly 'full stack' we will need to learn a frmework. Choosing the right weapon is hard, and will hit productivity at the start. To being with, I found that there's a mess to clean up mentally and understand before looking at each element of front end frameworks.</p> 
        <p>Taking the example of Angular2, with the core team preferring that you create applications with Typescript, there are many concepts that need to be learned as a newcomer: </p>

        <h3>1. Transpilation</h3>
        <p>With typescript, you're not actually looking at the final Javascript that's being rendered to the client. So there's a whole setup step to be made and understood here. If you don't understand every aspect of your code base, how can you possibly come to debug, and understand what it's doing?</p> 
        <p>Same with ES6, developers love shiny new stuff, and ES6 is full of it. unfortunately although it's a standard it's not yet completely available in all browsers. Meaning you need to transpile back to ES5 using a tool like <a href="https://babeljs.io/">Babel</a>.</p> 
        <p>A handy hint is that <a href="http://caniuse.com/">Caniuse.com</a> is your saviour, you might take some code offline that actually requires ES6 and your browser doesn't support it - you can check if you can run it without polyfills or transpilation first! I've lost many a brain cell on that one.</p>

        <h3>2. Build/Watch tasks</h3>
        <p>Again, you're looking to learn a facet of the eco system that happens everytime you change a file. What's doing it? How can you debug it?</p>
        <p>Tools like <a href="https://webpack.github.io/" target="_blank">Webpack</a> are on the rise (and the Angular2 team are looking of moving to Webpack), leaving Gulp, Grunt, Browserify behind, the darlings of the crazyness that was 2015.</p>

        <h3>3. Package Management</h3>
        <p>In the .NET world, we've had NuGet for a while now, but the Javascript world has Bower & NPM. Both require the installation of <a href="https://nodejs.org/en/">NodeJS</a>. Angular2 </p>
        <p>When you get as far as downloading an NPM 'quick start', the first thing you see in the package.json are scores of dependencies that look bat s**t insane at first, and I feel for you, really I do. I spend hours still thinking 'why are you using *that*'? A quick google search and you're in the well of needing to learn about another tool to even understand a thin slice of what you are looking for.</p>

        <h3>4. Module Loading</h3>
        <p>ES6 contains one of the most awaited features of Modules as part of the core languge. The implementation of modules required the use of tools such as RequireJS, AMD, SystemJS and CommonJS. There is still no way (as i write this) to natively include modules in a project. Angular 2 prefers at (again at the time of writing) the use of System JS (however there are noises of moving to Webpack). This means that instead of including all of our script tags in a HTML page, we just build a chain using the 'require' or 'import' keyword. Just like we would use a 'using' statement in C#. It's not that different.</p>

        <h2>Learn Javascript Foremost</h2>
        <p></p>
        <p>My preference is to start with vanilla JavaScript, maybe Angular 1.5, VueJS or React and get some knowledge under your belt. Start with no transpilation or build tasks at all, see the movement and flow of the language. You can use more traditional front end programming techniques such as pulling scripts from CDNs and writing script tags like you're used to with JQuery already rather than module loading.</p>

        <p>'What does my JavaScript look like?' with Angular 2 was my biggest issue though. JavaScript is a sometimes horrible yet wholey expressive language full of beauty in parts - if you know what it's doing! <a href="http://shop.oreilly.com/product/9780596517748.do" target="_blank">'JavaScript the good parts'</a> is a great place to start, as being from C# it's all about the types - and JavaScript has them. Kind of. In a shitty way already! <a href="http://shop.oreilly.com/product/0636920039303.do" target="_blank">'You don't know Javascript'</a> is also good to get up and running. The author <a href="https://twitter.com/getify">Getify</a> has a strong twitter presence, and although I don't agree with everything he writes, he's a very smart and switched on Javascript programmer.</p>
        
        <p>Using the console.log command in the Google Chrome developer tools as much as you can is a huge boon. 
            You can follow your code each step of the way, understand the idiosyncrasies of the language (some don't make any sense at first from an OO first perspective like closures, and the global scope).</p>

        <h2>Conclusion</h2>
        <p>Finally understand where the <em>framework starts</em> and <em>JavaScript ends</em>. Frameworks will provide you with alot of heavy lifting and techniques/tools to manage windows, variable scope, http calls (like Ajax) and cookies. But frameworks will come and go, every week you'll see a the next big saviour, but you're best to jump onto a mature framework at your stage, follow the herd as StackOverflow will have the most answers immediately for you, but learn JavaScript foremost. It's here to stay, frameworks aren't, and if that common denominator of JavaScript is your tool of choice you're winning.</p>

    </main>
    <div id="footer"></div>
  </body>
</html>






